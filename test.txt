1. 提取方法 (Extract Method)
描述：将一段复杂的代码块移到一个新的独立方法中。
目的：简化原始方法，使其更易理解；减少重复代码。
使用场景：当一个方法包含多个职责或逻辑过于复杂时。
2. 内联方法 (Inline Method)
描述：将一个方法的内容直接嵌入到调用该方法的地方，然后删除该方法。
目的：消除不必要的简单方法调用，使代码更加简洁。
使用场景：当方法体非常简单且只有一处调用时。
3. 重命名 (Rename)
描述：更改变量、方法、类等的名字，以更好地反映其用途。
目的：提高代码的可读性和自解释性。
使用场景：当现有名称不够清晰或误导时。
4. 移动方法 (Move Method)
描述：将一个方法从一个类移动到另一个类。
目的：确保方法位于最相关的类中，增强代码的逻辑一致性。
使用场景：当方法与当前类的关系较弱，而与另一类的关系更强时。
5. 引入参数对象 (Introduce Parameter Object)
描述：将多个相关参数组合成一个对象传递。
目的：减少参数列表长度，使方法签名更清晰。
使用场景：当方法有多个参数，且这些参数之间存在关联时。
6. 拆分条件表达式 (Decompose Conditional)
描述：将复杂的条件表达式分解为多个小部分，每个部分放在单独的方法中。
目的：使条件逻辑更容易理解和维护。
使用场景：当条件表达式难以阅读或理解时。
7. 替换算法 (Replace Algorithm)
描述：用更有效的算法替换现有的实现。
目的：优化性能或简化逻辑。
使用场景：当现有算法效率低下或难以维护时。
8. 提取接口 (Extract Interface)
描述：从现有类中提取出公共方法，形成一个新的接口。
目的：增加代码的灵活性和可扩展性，便于依赖注入和测试。
使用场景：当多个类需要共享相同的行为时。
9. 移除设置器 (Remove Setter)
描述：移除不需要的设置器（setter），改为通过构造函数或其他方式初始化属性。
目的：提高对象的不可变性，减少状态变化带来的复杂性。
使用场景：当对象的状态应该在创建时完全确定时。
10. 合并条件表达式 (Consolidate Conditional Expression)
描述：将多个条件表达式的返回值合并为一个单一的条件表达式。
目的：减少冗余，使代码更加紧凑。
使用场景：当多个条件表达式返回相同的值时。
11. 替换魔术数字为符号常量 (Replace Magic Number with Symbolic Constant)
描述：用具有明确意义的符号常量替换代码中的具体数值。
目的：提高代码的可读性和维护性。
使用场景：当代码中出现没有解释的数字时。
12. 引入外派 (Introduce Delegation)
描述：创建一个新方法，它将调用转发给另一个对象的方法。
目的：隐藏底层实现细节，简化高层接口。
使用场景：当需要隔离客户端代码与具体实现之间的耦合时。
13. 提取超类 (Extract Superclass)
描述：从两个或更多类中提取出共同的行为，形成一个新的父类。
目的：减少重复代码，提高代码的复用性。
使用场景：当多个类共享相似的功能时。
14. 内联临时变量 (Inline Temp)
描述：用表达式直接替换临时变量的所有引用，然后删除该临时变量。
目的：消除不必要的中间变量，使代码更简洁。
使用场景：当临时变量仅用于存储计算结果，且该计算结果只使用一次时。
15. 引入解释性变量 (Introduce Explaining Variable)
描述：将复杂的表达式或计算结果赋值给一个具有描述性的临时变量。
目的：使代码更易读，提高可维护性。
使用场景：当表达式过于复杂或难以理解时。
16. 复制并调整 (Copy and Adjust)
描述：复制现有代码，并根据新的需求进行适当调整。
目的：快速实现新功能，同时保持原有功能不变。
使用场景：当需要实现类似但略有不同的功能时。
17. 封装字段 (Encapsulate Field)
描述：将公有字段变为私有，并提供访问器（getter）和修改器（setter）。
目的：控制对字段的访问，增强数据封装性。
使用场景：当需要限制对字段的直接访问时。
18. 替换继承为委托 (Replace Inheritance with Delegation)
描述：用委托关系替换继承关系，即让一个类持有另一个类的实例，并将调用转发给该实例。
目的：减少类之间的耦合，提高代码的灵活性。
使用场景：当继承关系过于复杂或不适合时。
19. 替换委托为继承 (Replace Delegation with Inheritance)
描述：将委托关系转换为继承关系，即让一个类继承另一个类，并重写必要的方法。
目的：简化代码结构，提高代码的可扩展性。
使用场景：当委托关系导致代码过于复杂时。
20. 引入工厂方法 (Introduce Factory Method)
描述：创建一个工厂方法来负责对象的创建，而不是直接使用构造函数。
目的：提高代码的灵活性和可测试性，便于扩展和维护。
使用场景：当对象的创建逻辑较为复杂或可能发生变化时。
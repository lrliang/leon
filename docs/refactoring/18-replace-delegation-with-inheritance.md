## 简介

“替换委托为继承”（Replace Delegation with
Inheritance）是一种常用的重构技术，能够优化代码结构，简化类之间的关系，让代码复用更为自然、高效。当使用委托机制导致代码分散、重复，或者使得类层次关系不够清晰时，采用继承关系来替换委托往往能提升代码的可读性与维护性。以下是进行“替换委托为继承”重构的详细步骤。

## 替换委托为继承 (Replace Delegation with Inheritance)的详细步骤

### 1. 识别适合替换的委托关系

- **代码冗余检查**：查看现有代码，找出那些通过委托方式实现功能，但委托代码在多个地方重复出现的场景。若不同类中针对同一委托功能有相似的调用逻辑，可能适合转为继承。
- **关系复杂度评估**：分析类之间的委托关系，若委托链条过长、过于复杂，导致理解和跟踪代码执行流程困难，就需要考虑简化为继承关系。
- **功能共性分析**：确定委托类与被委托类之间是否存在明显的“is-a”关系，也就是判断委托类本质上是否能被归为被委托类的一种特殊类型，如果是，那么替换为继承更合适。

### 2. 移除委托成员

- **删除委托变量**：在原本使用委托的类中，删除用于委托的实例变量，这类变量之前负责指向被委托的对象实例，移除它以切断委托纽带。
- **清理相关代码**：同时删除与该委托变量初始化、维护相关的代码片段，比如构造函数里对委托变量的实例化语句，以及使用委托变量进行调用的前置准备代码。

### 3. 建立继承关系

- **修改类声明**：更改使用委托的类的声明，让它继承自原本被委托的类。通过继承，子类能够自动获取父类的属性与方法，无需再借助委托机制。
- **调整访问权限**：检查继承后的方法和属性访问权限，若存在因继承而导致访问受限的情况，按照需求调整访问修饰符，确保功能的正常调用，通常是将一些之前通过委托公开访问的方法，在子类中也保持合适的可见性。

### 4. 修正方法调用

- **替换委托调用**：在继承后的子类里，把原来通过委托变量调用方法的代码，替换成直接调用继承自父类的同名方法。由于子类现在继承了父类的成员，无需再绕经委托变量来访问相关功能。
- **清理冗余代码**：移除因委托而产生的额外封装、转换代码，简化方法实现，让代码直接依赖继承体系下的原生功能，提升执行效率。

### 5. 更新外部代码引用

- **查找引用点**：全面搜索项目中对原委托类的使用之处，因为类关系发生了变化，外部代码调用方式大概率需要调整。
- **调整调用方式**：把基于委托的调用形式，更新为基于继承的调用形式，比如原来是 `delegateClass.delegateInstance.method()`
  ，现在要改成 `subClass.method()` 这种符合继承调用习惯的形式。

### 6. 测试

- **编译代码**：首先保证代码能够顺利编译，检查因类关系变更、变量和方法移除或新增等操作是否引入语法错误。
- **运行测试**：执行所有相关的单元测试，确认重构没有带来新的逻辑错误，原有功能依然完好无损。
- **手动测试**：针对关键业务逻辑，尤其是涉及到变更前后调用方式不同的部分，如有必要，手动模拟用户操作进行测试，避免出现功能异常。

### 7. 代码审查

- **同行评审**：邀请同事或者其他团队成员审查重构后的代码，从第三方视角审视代码质量、结构合理性，查看是否遗漏了外部引用更新等关键问题。
- **文档更新**：如果项目有维护文档的习惯，及时更新相关文档，记录原本的委托关系如何转变为继承模式，方便后续开发人员理解代码演变。

## 示例

假设有如下的委托关系代码：

```java
class Printer {
    public void print() {
        System.out.println("Printing...");
    }
}

class AdvancedPrinter {
    private Printer printer;

    public AdvancedPrinter() {
        this.printer = new Printer();
    }

    public void print() {
        printer.print();
    }
}
```

### 步骤如下：

1. **识别适合替换的委托关系**：
    - AdvancedPrinter类对Printer类的委托较为简单，且AdvancedPrinter本质上是一种特殊的Printer，适合替换为继承关系。
2. **移除委托成员**：
    - 在AdvancedPrinter类中，删除`private Printer printer;`这个委托变量。
    - 同时删除构造函数里`this.printer = new Printer();`这一初始化代码。
3. **建立继承关系**：
    - 修改AdvancedPrinter类的声明，使其继承自Printer类，即`class AdvancedPrinter extends Printer`。
4. **修正方法调用**：
    - 在AdvancedPrinter类里，`print`方法直接调用继承自父类的`print`方法，无需再通过委托变量，所以`print`方法代码可精简。
5. **更新外部代码引用**：
    - 假设原本有代码`AdvancedPrinter ap = new AdvancedPrinter(); ap.print();`，无需更改实际调用语句，因为方法签名未变，只是底层实现换成了继承。
6. **测试**：
    - **编译代码**：检查编译无误。
    - **运行测试**：运行单元测试，确认功能正常。
7. **代码审查**：
    - **同行评审**：让同事审核。
    - **文档更新**：更新文档说明重构变动。

### 重构后的代码：

```java
class Printer {
    public void print() {
        System.out.println("Printing...");
    }
}

class AdvancedPrinter extends Printer {
}
``` 